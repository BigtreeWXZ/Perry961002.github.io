[{"title":"环形链表问题的证明","date":"2019-03-14T16:15:02.000Z","path":"2019/03/15/list-cycle/","text":"一、说明在LeetCode上有这样两道关于环形链表的题目： No.141 描述：给定一个链表，判断链表中是否有环。题目链接 No.142 描述：给定一个链表，返回链表开始入环的第一个节点。题目链接 这篇文章主要做一下解题方法—快慢指针法的正确性证明。 二、证明1.证明快慢指针在环中是可以恰好相遇的 设链表的头结点为$x_0$，环的起始结点为$x_s$，环的结点个数为$l$。当我们从$x_0$开始遍历链表的话可以得到下面的一个无穷序列：$$x_0, x_1,\\cdots,x_s,x_{s+1},\\cdots,x_{s+l-1},x_s,\\cdots$$假设$j$是$l$的整数倍且是满足$j&gt;s$的最小的那一个，对于任意的正整数$k(k\\geq2)$，考虑两个结点位置$x_j$和$x_{kj} $（即慢指针走到了$x_j$，快指针走到了$x_{kj}$），容易知道的事实是：$x_j$肯定在环中。那么$x_{kj}$也在环中，因为$kj=j+(k-1)j$，可以认为$x_{kj}$是从$x_j$开始多走了$k-1$个$j$步，所以$x_j=x_{kj}​$。 综上，两个指针一定会恰好相遇！ 那么为了以最快的速度让两个指针相遇，我们应该让$k$尽可能小，所以$k$取2。所以让慢指针走1步，而快指针走2步！ 2.解题代码 其他题目的代码(C++, Java, Python)，包括一些经典数据结构和算法的实现也放在了我的GitHub上。 2.1.第一题代码12345678910111213141516171819202122/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool hasCycle(ListNode *head) &#123; ListNode* slow = head; //慢指针 ListNode* fast = head; //快指针 while(slow != NULL &amp;&amp; fast != NULL &amp;&amp; fast-&gt;next != NULL)&#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; //快指针走两步 if(slow == fast) return true; &#125; return false; &#125;&#125;; 2.2.第二题代码12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; ListNode* slow = head; ListNode* fast = head; while(fast != NULL &amp;&amp; fast-&gt;next !=NULL)&#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; if(slow == fast)&#123; fast = head; while(fast != slow)&#123; fast = fast-&gt;next; slow = slow-&gt;next; &#125; return slow; &#125; &#125; return NULL; &#125;&#125;; 本文章由Perry创作，采用知识共享署名-非商业性使用-相同方式共享 3.0 中国大陆许可协议进行许可。凡是转载的文章，翻译的文章，或者由其他作者投稿的文章，版权归原作者所有。","comments":true,"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"我的书单（一）","date":"2019-03-12T04:55:19.000Z","path":"2019/03/12/booklist1/","text":"读书带给人的是精神上的富足，会让你在精神得到满足之余，有一种孤独感。 大学期间，从大三开始陆陆续续也读了一点书籍，好多也是因为别人的推荐才知道的，也很感激那些推荐者，所以今天也来推荐一下我读过的一些好书！这些书有的是读完的，有的正在读，但都是我觉得还不错的书。 一、数学类 数学是自然科学的基础，计算机更是由数学家创造出来的，培养好的数学素养对以后的学习是非常有必要的！ 1.代数 – Artin 这本书是由当代领袖型代数学家与代数儿何学家之一的Atrin写作的，是一本代数学的经典著作，既介绍了矩阵运算、群、向量空间、线性变换、对称等较为基本的内容，又介绍了环、模、域、伽罗瓦理论等较为高深的内容，对于提高数学理解能力、增强对代数的兴趣是非常有益处的。 2.组合数学 – 冯荣权、宋春伟 这本书出自北大数学系教授之手，注重对抽象概念和定理的理解，强调方法的运用以及组合数学在各个领域的应用。因为理论性比较高，所以初步读起来会觉得比较困难，但理解了之后会觉得非常有趣。 二、计算机类1.计算机程序的构造和解释 这本书是MIT盛行多年的一本教材，它不仅仅是在教授计算机技术，我觉得里面更多的计算机科学方面的知识，作者使用了简单的函数式语言Scheme带领读者初步探索了精彩绝伦的计算机科学理论的世界！个人觉得是目前读过最精彩的书！ 前4章的习题解答我也放在了GitHub上。 2.算法导论 不多说，这本书是学习算法的人都有读过的，里面的内容也是非常的丰富，想读懂里面的内容是需要一定的基础的，想读完它更是需要花费大量的时间的。 我的一些算法练习和本书里一些经典算法的实现代码放在了这里。 3.编程珠玑 在书中，作者选取许多具有典型意义的复杂编程和算法问题，生动描绘了历史上众大师们在探索解决方案中发生的轶事、走过的弯路和不断精益求精的历程，引导读者像真正的程序员和软件工程师那样富于创新性地思考，并透彻阐述和总结了许多独特而精妙的设计原则、思考和解决问题的方法以及实用程序设计技巧。解决方案的代码均以C/C++语言编写，不仅有趣，而且有很大的实战示范意义。每章后所附习题极具挑战性和启发性，书末给出了简洁的解答。 4.C++ Primer 这本是久负盛名的 C++经典教程，深入浅出地为我们讲解了C++11标准里的各种知识和原理，教会我们怎么进行高效的现代C++编程 5.Effective C++ 这是C++领域的经典大作，与《C++ Primer》的广博不同，这本书只是列出了55个编程准则，但都是非常实用的经验准则，是一本短小精悍的“专家经验积累” 6.统计学习方法 书中罗列了10个统计学习方法，并且书的厚度相比同类的其他书籍真的很少，适合入门学习。 7.机器学习 周志华的经典之作，不做其他介绍。 本文章由Perry创作，采用知识共享署名-非商业性使用-相同方式共享 3.0 中国大陆许可协议进行许可。凡是转载的文章，翻译的文章，或者由其他作者投稿的文章，版权归原作者所有。","comments":true,"tags":[{"name":"书单","slug":"书单","permalink":"http://yoursite.com/tags/书单/"},{"name":"BookList","slug":"BookList","permalink":"http://yoursite.com/tags/BookList/"}]},{"title":"SICP的小练习--Scheme语言实现3个经典的排序算法","date":"2019-02-25T08:09:54.000Z","path":"2019/02/25/scheme-sort/","text":"一、说明 从去年11月份开始了《计算机程序的构造和解释》这本书的学习，开始接触了函数式。学习过程中也对编程有了新的理解，对递归这一程序设计技术也有了更深的掌握。其间为了自娱自乐用Scheme这一小众的函数式语言实现了3个经典排序算法，分别是快速排序、归并排序、堆排序。 目前我已经学习并完成了那本书的前三章的内容和习题，所有的代码也放在了GitHub仓库里，如果有对那本书感兴趣的朋友，可以一起讨论学习。 二、具体算法实现1.快速排序1.1.算法核心思想 每次选取第一个元素作为基准，并采用过滤器filter将剩余元素中小于等于基准的作为small部分、剩余元素中大于基准的作为big部分，然后对small和big部分进行快速排序，最后按small-基准-big的顺序组合成新的列表，直到列表中只有一个元素为止. 1.2.完整代码实现12345678(define (quicksort L) (if (null? L) '() (let ((small (quicksort (filter (lambda (x) (&lt;= x (car L))) (cdr L)))) (big (quicksort (filter (lambda (x) (&gt; x (car L))) (cdr L))))) (append small (cons (car L) big))))) 代码文件 2.归并排序2.1.算法核心思想 合并两个列表L1、L2 如果L1、L2中有一个为空，则返回另一个. 否则分别取L1、L2的首元素x1、x2 如果x1小于等于x2，则将x1作为新列表的首元素，并继续合并L1的剩余部分和L2. 如果x1大于x2，则将x2作为新列表的首元素，并继续合并L1和L2的剩余部分. 12345678(define (merge L1 L2) (cond ((null? L1) L2) ((null? L2) L1) (else (let ((x1 (car L1)) (x2 (car L2))) (if (&lt;= x1 x2) (cons x1 (merge (cdr L1) L2)) (cons x2 (merge L1 (cdr L2)))))))) 归并排序 每次选取列表的头两个元素进行合并然后舍弃，并将合并之后元素放置列表末尾，继续对新列表进行归并排序，直到列表中只有一个元素. 123456789101112(define (merge-sort L) (define (transform x) (if (number? x) (list x) x)) (cond ((null? L) '()) ((= (length L) 1) (car L)) (else (let ((l1 (transform (car L))) (l2 (transform (cadr L)))) (let ((new (list (merge l1 l2)))) (merge-sort (append (cddr L) new))))))) 2.2.完整代码实现 代码文件 3.推排序3.1.算法核心思想 首先将数组映射为一棵完全二叉树 规则：对于 i 下标位置的元素，它的左孩子下标为 2*i+1，右孩子下标为 2*(i+1)​. 维护一个以root下标为根，末尾下标为len的大根堆 如果root的两个孩子有比它大的，则将root和那个最大元素交换位置，并对那个子树进行递归维护. 123456789101112131415161718192021(define (MaxHeapify heap root len) (define (Left i) (+ (* i 2) 1)) (define (Right i) (* (+ i 1) 2)) (let ((left (Left root)) (right (Right root)) (largest root)) (begin (if (and (&lt;= left len) (&gt; (vector-ref heap left) (vector-ref heap root))) (set! largest left)) (if (and (&lt;= right len) (&gt; (vector-ref heap right) (vector-ref heap largest))) (set! largest right)) (if (not (= largest root)) (let ((head (vector-ref heap root))) (begin (vector-set! heap root (vector-ref heap largest)) (vector-set! heap largest head) (MaxHeapify heap largest len))))))) 初始化大根堆 从堆中的最后一个有孩子的节点开始从右向左、从下向上，以每个节点为根维护一个大根堆. 1234567(define (BuildMaxHeap heap) (define (build-iter i) (if (&gt;= i 0) (begin (MaxHeapify heap i (- (vector-length heap) 1)) (build-iter (- i 1))))) (build-iter (- (div (vector-length heap) 2) 1))) 堆排序 从初始的大根堆开始，每次将0下标位置和len下标位置的元素交换，并len := len-1，然后继续对0到len位置的元素进行堆排序，直到len = 0. 123456789101112(define (HeapSort heap) (define (sort-iter i) (if (&gt;= i 1) (let ((max (vector-ref heap 0))) (begin (vector-set! heap 0 (vector-ref heap i)) (vector-set! heap i max) (MaxHeapify heap 0 (- i 1)) (sort-iter (- i 1)))))) (BuildMaxHeap heap) (sort-iter (- (vector-length heap) 1)) heap) 3.2.完整代码实现 代码文件 本文章由Perry创作，采用知识共享署名-非商业性使用-相同方式共享 3.0 中国大陆许可协议进行许可。凡是转载的文章，翻译的文章，或者由其他作者投稿的文章，版权归原作者所有。","comments":true,"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"Scheme","slug":"Scheme","permalink":"http://yoursite.com/tags/Scheme/"},{"name":"函数式","slug":"函数式","permalink":"http://yoursite.com/tags/函数式/"},{"name":"SICP","slug":"SICP","permalink":"http://yoursite.com/tags/SICP/"}]},{"title":"利用Github和Hexo搭建Yilia主题的博客","date":"2019-02-21T13:21:14.000Z","path":"2019/02/21/hexo-yilia/","text":"一、说明 前面几天时间利用Github和Hexo搭建Yilia主题的博客，过程中也踩了很多的坑，现在也到了填坑的时候了。 废话不多说，现在正式开始教程吧。 1.基本软件安装 首先我们需要从Node.js官网下载并安装这个软件。 安装成功之后我们在cmd窗口中输入命令：node --version，如果可以得到相对应的版本号则说明安装成功，否则请将安装目录添加到PATH环境变量中。 另外我们还需要安装Git，并且还需要配置与Github的SSH Key，需要的话可以参考我的上一篇文章。 2.创建Github仓库 登录GitHub后我们新建一个名为userName.github.io的仓库，userName就是你账户的名字。 建好之后打开这个仓库的Settings页面，在GitHub Pages我们可以看到类似于这样的显示： 这里绿色区域显示的网址就是我们博客的网址，因为这个网址有点长，资金允许的话我们可以将它绑定到自己申请的域名，这将在后面进行介绍。 二、Hexo的安装和一些基本命令、配置1.安装Hexo 打开cmd窗口，运行命令：npm install -g hexo进行安装。 初始化Hexo：新建一个名为blog的文件夹，在PowerShell窗口中运行命令hexo init。 重新打开文件夹之后我们发现多出了这样一些文件 source文件夹：这里存放的是博客所有的资源文件，书写文章的Markdown文件存放在_posts子文件夹中，文章的图片资料可以新建imgs文件夹并存放。 themes文件夹：这里存放的是博客的主题文件，其中的landspace是默认的主题文件，之后我们更换的Yilia主题文件也将存放在这里。 _config.yml文件：这是博客的一些基本配置记录，我们后面将对它进行更改。 2.基本配置打开_config.yml文件进行配置 基本信息展示： 部署方式配置 关于头像和站点图标的更换将在更换主题之后进行。 3.基本命令 生成静态页面：hexo g。 启动本地服务器：hexo s。 默认的端口号是4000，如果冲突的话可以通过命令hexo s -p5000更换指定的端口号。 之后我们就可以在浏览器中访问http://localhost:4000查看自己的博客情况。 新建文章：运行命令hexo new &quot;xxxx&quot;，在source\\_posts文件夹生成新的Markdown文件，后面就可以在这个文件上完成自己的文章。 部署到GitHub：在搭建完博客或者写完文章之后我们需要把它们部署到GitHub上供人浏览。我们依次运行下面的两条命令完成： hexo clean hexo d -g 三、更换Yilia主题及它的基本配置1.更换主题之前说过的，我们可以将下载好的主题文件放在themes文件夹里进行主题更换。这里提供了很多别人开发好的主题，我使用的是Yilia主题。下面具体说说怎么更换： 在themes文件夹下打开Git Bash，运行git clone git@github.com:litten/hexo-theme-yilia.git。 打开blog文件夹下的_config.yml文件，将其中的theme属性的值改为刚刚下好的文件名即可。 1theme: hexo-theme-yilia 2.基本配置2.1.更换头像和站点图标 打开文件夹themes\\hexo-theme-yilia\\source\\img，将头像、站点图标以及两个打赏二维码图片放在这里。 打开主题文件夹下的_config.yml文件，并对avatar和favicon做如下更改： 12favicon: /img/favicon.jpgavatar: /img/avatar.jpg 2.2.配置打赏图片 还是对_config.yml文件进行修改： 1234# 支付宝二维码图片地址，跟你设置头像的方式一样alipay: /img/alipay.jpg# 微信二维码图片地址weixin: /img/weixin.jpg 2.3.标签功能缺失模块的补充 在blog文件夹下执行命令：npm i hexo-generator-json-content --save 在blog文件夹中的_config.yml文件末尾添加代码： 123456789101112131415161718jsonContent: meta: false pages: false posts: title: true date: true path: true text: true raw: false content: false slug: false updated: false comments: true link: false permalink: false excerpt: false categories: false tags: true 2.4.百度统计设置百度统计官网 注册完之后点击新增网站，前面的两个值填写的是GitHub为我们生成的网址即可 在代码获取页面复制官方生成的代码 将复制的代码添加到目录hexo-theme-yilia\\layout\\_partial中的baidu_tongji.ejs中，格式为： 12&lt;% if (theme.baidu_tongji) &#123; %&gt;# 你刚复制的所有代码 打开主题目录下的_config.yml文件，将其中的baidu_analytics的值修改为统计代码中hm.src值的’?‘之后一段字符。 123# Miscellaneousbaidu_analytics: '0f94e44d75ef0e72600xxxxxxxxxxxxx'google_analytics: '' 2.5.其他一些链接更改 这里主要是我对主题里一些链接的更改： 1234567891011121314151617# SubNavsubnav: github: \"https://github.com/Perry961002\" weibo: \"#\" rss: \"#\" mail: \"mailto:Perry961002@163.com\" #友情链接friends: Github官网: https://github.com/ Markdown编辑器Typora: https://www.typora.io/ 阿里云: https://www.aliyun.com/ VSCode官网: https://code.visualstudio.com/ LeetCode中国: https://leetcode-cn.com/#自我展示aboutme: 爱好数学和算法的码农&lt;br&gt;&lt;br&gt;喜欢乒乓球的吃货。。。 四、博客进阶功能设置1.网站访问量和文章阅读量统计 这里我使用的是不蒜子提供的插件 打开目录hexo-theme-yilia\\layout\\_partial下的footer.ejs文件，在末尾添加代码 12&lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 还是在footer.ejs文件中，在footer-left和footer-right标签之间添加代码 123456&lt;span id=&quot;busuanzi_container_site_pv&quot;&gt; 本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt;&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 本站访客数&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人次&lt;/span&gt; 打开同目录下的article.ejs文件，在&lt;%- partial(&#39;post/title&#39;, {class_name: &#39;article-title&#39;}) %&gt;一行下添加代码 123456789&lt;!-- 显示阅读和评论数 --&gt;&lt;% if (!index)&#123; %&gt; &lt;br/&gt; &lt;a class=&quot;cloud-tie-join-count&quot; href=&quot;javascript:void(0);&quot; style=&quot;color:gray;font-size:14px;&quot;&gt; &lt;span class=&quot;icon-sort&quot;&gt;&lt;/span&gt; &lt;span id=&quot;busuanzi_container_page_pv&quot; style=&quot;color:#ef7522;font-size:14px;&quot;&gt; 本文阅读量: &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt;次 &amp;nbsp;&amp;nbsp; &lt;/span&gt; &lt;/a&gt; 效果： 网站访问量： 文章阅读量： 2.评论功能配置 在主题目录下的_config.yml文件中我们发现作者提供了多种方式来实现评论功能，但因为一些原因很多方式已经不能使用，这里我采用了Gitment评论功能。 Gitment是使用的GitHub Issues作为评论系统。 2.1.在GitHub上创建OAuth Apps 登录自己的Github，进入Settings--Developer settings页面，点击New OAuth App 这里name可以随便写，Homepage URL填GitHub提供的网址 如果博客绑定的域名，callback URL就需要使用绑定域名，否则和上面一样，最后确定即可。 完成之后可以得到 2.2.配置_config.yml文件 打开主题目录下的_config.yml文件，做下面的修改 1234567#5、Gitmentenable: truegitment_owner: Perry961002 #你的 GitHub IDgitment_repo: 'perry961002.github.io' #存储评论的 repogitment_oauth: client_id: 'e686axxxxxxxxx' #client ID client_secret: 'aea668xxxxxxxxxx' #client secret 2.3.配置Gitment的中文显示、解决Validation Failed错误 打开目录hexo-theme-yilia\\layout\\_partial\\post下的gitment.ejs文件，将2、3两行修改为 12&lt;link rel=&quot;stylesheet&quot; href=&quot;https://billts.site/extra_css/gitment.css&quot;&gt;&lt;script src=&quot;https://billts.site/js/gitment.js&quot;&gt;&lt;/script&gt; 将id属性的值修改为 1id: &quot;&lt;%= page.date %&gt;&quot; 最终效果： 3.文章目录功能 打开目录hexo-theme-yilia\\source下的main.0cf68a.css文件(这里文件名中间的那一段编号可能不一样)，添加下面的代码： 123456789/* 新添加的 */#container .show-toc-btn,#container .toc-article&#123;display:block&#125;.toc-article&#123;z-index:100;background:#fff;border:1px solid #ccc;max-width:250px;min-width:150px;max-height:500px;overflow-y:auto;-webkit-box-shadow:5px 5px 2px #ccc;box-shadow:5px 5px 2px #ccc;font-size:12px;padding:10px;position:fixed;right:35px;top:129px&#125;.toc-article .toc-close&#123;font-weight:700;font-size:20px;cursor:pointer;float:right;color:#ccc&#125;.toc-article .toc-close:hover&#123;color:#000&#125;.toc-article .toc&#123;font-size:12px;padding:0;line-height:20px&#125;.toc-article .toc .toc-number&#123;color:#333&#125;.toc-article .toc .toc-text:hover&#123;text-decoration:underline;color:#2a6496&#125;.toc-article li&#123;list-style-type:none&#125;.toc-article .toc-level-1&#123;margin:4px 0&#125;.toc-article .toc-child&#123;&#125;@-moz-keyframes cd-bounce-1&#123;0%&#123;opacity:0;-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)&#125;60%&#123;opacity:1;-o-transform:scale(1.01);-webkit-transform:scale(1.01);-moz-transform:scale(1.01);-ms-transform:scale(1.01);transform:scale(1.01)&#125;100%&#123;-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)&#125;&#125;@-webkit-keyframes cd-bounce-1&#123;0%&#123;opacity:0;-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)&#125;60%&#123;opacity:1;-o-transform:scale(1.01);-webkit-transform:scale(1.01);-moz-transform:scale(1.01);-ms-transform:scale(1.01);transform:scale(1.01)&#125;100%&#123;-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)&#125;&#125;@-o-keyframes cd-bounce-1&#123;0%&#123;opacity:0;-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)&#125;60%&#123;opacity:1;-o-transform:scale(1.01);-webkit-transform:scale(1.01);-moz-transform:scale(1.01);-ms-transform:scale(1.01);transform:scale(1.01)&#125;100%&#123;-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)&#125;&#125;@keyframes cd-bounce-1&#123;0%&#123;opacity:0;-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)&#125;60%&#123;opacity:1;-o-transform:scale(1.01);-webkit-transform:scale(1.01);-moz-transform:scale(1.01);-ms-transform:scale(1.01);transform:scale(1.01)&#125;100%&#123;-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)&#125;&#125;.show-toc-btn&#123;display:none;z-index:10;width:30px;min-height:14px;overflow:hidden;padding:4px 6px 8px 5px;border:1px solid #ddd;border-right:none;position:fixed;right:40px;text-align:center;background-color:#f9f9f9&#125;.show-toc-btn .btn-bg&#123;margin-top:2px;display:block;width:16px;height:14px;background:url(http://7xtawy.com1.z0.glb.clouddn.com/show.png) no-repeat;-webkit-background-size:100%;-moz-background-size:100%;background-size:100%&#125;.show-toc-btn .btn-text&#123;color:#999;font-size:12px&#125;.show-toc-btn:hover&#123;cursor:pointer&#125;.show-toc-btn:hover .btn-bg&#123;background-position:0 -16px&#125;.show-toc-btn:hover .btn-text&#123;font-size:12px;color:#ea8010&#125;.toc-article li ol, .toc-article li ul &#123; margin-left: 30px;&#125;.toc-article ol, .toc-article ul &#123; margin: 10px 0;&#125; 打开目录hexo-theme-yilia\\layout\\_partial下的article.ejs文件，在&lt;/header&gt; &lt;% } %&gt;下添加代码： 123456789101112131415161718192021222324252627&lt;!-- 目录内容 --&gt;&lt;% if (!index &amp;&amp; post.toc)&#123; %&gt; &lt;p class=&quot;show-toc-btn&quot; id=&quot;show-toc-btn&quot; onclick=&quot;showToc();&quot; style=&quot;display:none&quot;&gt; &lt;span class=&quot;btn-bg&quot;&gt;&lt;/span&gt; &lt;span class=&quot;btn-text&quot;&gt;文章导航&lt;/span&gt; &lt;/p&gt; &lt;div id=&quot;toc-article&quot; class=&quot;toc-article&quot;&gt; &lt;span id=&quot;toc-close&quot; class=&quot;toc-close&quot; title=&quot;隐藏导航&quot; onclick=&quot;showBtn();&quot;&gt;×&lt;/span&gt; &lt;strong class=&quot;toc-title&quot;&gt;文章目录&lt;/strong&gt; &lt;%- toc(post.content) %&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; function showToc()&#123; var toc_article = document.getElementById(&quot;toc-article&quot;); var show_toc_btn = document.getElementById(&quot;show-toc-btn&quot;); toc_article.setAttribute(&quot;style&quot;,&quot;display:block&quot;); show_toc_btn.setAttribute(&quot;style&quot;,&quot;display:none&quot;); &#125;; function showBtn()&#123; var toc_article = document.getElementById(&quot;toc-article&quot;); var show_toc_btn = document.getElementById(&quot;show-toc-btn&quot;); toc_article.setAttribute(&quot;style&quot;,&quot;display:none&quot;); show_toc_btn.setAttribute(&quot;style&quot;,&quot;display:block&quot;); &#125;; &lt;/script&gt; &lt;% &#125; %&gt; &lt;!-- 目录内容结束 --&gt; 需要注意的是：如果想在页面中显示目录，要在文章的Markdown的开头加入toc: true这样一句话。 效果： 五、绑定域名1.购买域名 首先需要在阿里云的域名模块购买属于自己的域名，我这里使用的是.com结尾的域名，加入云解析服务，第一年支付了73.36人民币。 2.域名解析 点开解析设置页面，添加两个记录，记录类型选CNAME，主机记录分别写@和www，记录值填GitHub生成的网址 在博客目录下的source文件夹下新建名为CNAME的文件，将域名信息写入并保存，比如我的就是填perry96.com。稍等几分钟之后就可以通过访问域名来访问自己的博客。 本文章由Perry创作，采用知识共享署名-非商业性使用-相同方式共享 3.0 中国大陆许可协议进行许可。凡是转载的文章，翻译的文章，或者由其他作者投稿的文章，版权归原作者所有。","comments":true,"tags":[{"name":"Github","slug":"Github","permalink":"http://yoursite.com/tags/Github/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"Yilia","slug":"Yilia","permalink":"http://yoursite.com/tags/Yilia/"},{"name":"博客","slug":"博客","permalink":"http://yoursite.com/tags/博客/"}]},{"title":"Git和Github初次使用及配置","date":"2019-02-21T03:26:58.000Z","path":"2019/02/21/git-github/","text":"一、简单介绍 Git是一个开源的分布式版本控制系统，它可以很高效地进行项目版本管理。 Github是一个只支持Git作为唯一版本管理工具的面向开源和私有软件项目的托管平台。 二、Git安装及本地账户配置1.Git安装 我们需要从Git官网下载适合版本的安装包进行安装，因为过程中没有需要注意的地方，这里不再赘诉。 2.Git的账户配置 我们右击鼠标，打开Git Bash，输入下面两条命令进行用户名和邮箱设置： 12git config --global user.name \"username\" //引号内为GitHub用户名git config --global user.email useremail@example.com //这里用GitHub的注册邮箱 三、配置SSH访问Github 这里需要你提前注册一个Github账号，方法不再赘述。 1.Git创建本地SSH Key 右键鼠标，打开Git Bash，输入下面的命令创建本地SSH Key 1ssh-keygen -t rsa -C \"useremail@example.com\" //此处“C”要大写，邮箱使用GitHub注册邮箱 输入后中间会提示选择生产路径以及设置密码，为了后面使用方便我们一路回车跳过即可 创建成功之后会看见The key&#39;s randomart image is:这样一句话，下面会显示出一堆看不懂的图案。 之后我们打开.ssh文件夹中的id_rsa.pub文件，复制其中的所有内容，这里一定要全部复制，包括换行。 2.添加到Github 登录Github，点击Settings—SSH and GPG keys—New SSH key Title里的内容随便填，Key中粘贴之前复制的本地SSH key。 3.测试是否成功 打开Git Bash，输入下面的命令 1ssh -T git@github.com 如果配置成功将会出现下面的文字 1You&apos;ve successfully authenticated, but GitHub does not provide shell access. 本文章由Perry创作，采用知识共享署名-非商业性使用-相同方式共享 3.0 中国大陆许可协议进行许可。凡是转载的文章，翻译的文章，或者由其他作者投稿的文章，版权归原作者所有。","comments":true,"tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"},{"name":"Github","slug":"Github","permalink":"http://yoursite.com/tags/Github/"}]}]