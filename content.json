[{"title":"SICP读书笔记--第3章《模块化、对象和状态》","date":"2019-03-22T22:00:00.000Z","path":"2019/03/23/sicp-third/","text":"一、说明 在第1章中我们知道了如何进行过程抽象，如何利用高阶过程达到更高一级的抽象。 在第2章中我们学会了数据抽象，知道了它的一般方法，利用它对系统各层次之间建立抽象屏障，利用闭包性质设计层次性结构数据，并学会了序列操作的一般性约定方法，深刻领会了数据导向的程序设计方法，并学会利用了消息传递进行程序分派。 这两章的内容都可以利用代换模型进行解释，可是在自然界中的对象都不可避免地要考虑由时间带来的状态问题，本章就是通过引入对象、状态和赋值概念后完成对现实世界的模拟。 本章内容分布： 3.1赋值和局部状态 3.2求值的环境模型 3.3用变动数据做模拟 3.4并发：时间是一个本质问题 3.5流 我的解题代码 二、总结 本章中我们将看到一个强有力的、用于构造模拟真实物理系统的程序的设计策略：基于被模拟系统的结构去设计程序的结构。 构造与物理系统中每一个对象相对应的计算对象。 对系统里的每种活动，在计算系统里定义对应的符号操作。 两种组织策略： 将注意力集中在对象上，考虑它们的行为可能随时间的变化而不断变化。 将注意力集中在流过系统的信息流上，看作信号处理系统，考虑对流的一系列动作如过滤、映射、组合等。 新的计算模型：环境模型。 1.赋值和局部状态 对象状态的描述：引入它的一些局部状态变量，维持有关这一对象的历史。 对象间的交互：建立起一个对象的状态变量与其他对象状态变量之间的联系。 1.1赋值操作 使用了特殊形式set!，语法： (set! &lt;name&gt; &lt;new-value&gt;)，这里&lt;name&gt;将是一个符号，&lt;new-value&gt;是任何表达式。 set!将修改&lt;name&gt;，使它的值变成求值&lt;new-value&gt;的结果。 使用了特殊形式begin，语法： (begin &lt;exp1&gt; &lt;exp2&gt; ... &lt;expk&gt;)，导致表达式&lt;exp1&gt;到&lt;expk&gt;按顺序求值，&lt;expk&gt;的值作为整个begin形式的值返回。 123456789101112(define (make-withdraw balance) (lambda (amount) (if (&gt;= balance amount) (begin (set! balance (- balance amount)) balance) \"Insufficient funds\")))(define W1 (make-withdraw 100))(define W2 (make-withdraw 100))(W1 20) ;==&gt; 80(W1 30) ;==&gt; 70 1.2赋值带来的利益 一种维护模块化设计的强大技术： 将系统看作一集带有局部状态的对象，从一个复杂计算过程中一部分的角度看，其他部分都像是在随时间不断变化，它们隐藏起自己的随时间变化的内部状态。 1.3赋值带来的代价 破坏了前两章一直存在的一个特性：引用透明性，使确定能否通过等价地表达式代换去简化表达式变成了复杂的问题。 强迫人们去考虑赋值的顺序问题，保证每个语句所用的是被修改变量的正确版本。 2.求值的环境模型 一个环境就是框架的一个序列，每个框架是包含着一些约束的一个表格，这些约束将一些变量关联与对应的值。 每个框架包含着一个指针，指向这个框架的外围环境。 一个变量相对于某个特定环境的值，就是在这个环境中，包含着该变量的第一个框架里这个变量的约束值。 2.1求值规则过程应用的环境模型的两条规则： 将一个过程对象应用于一集实际参数，将构造出一个新框架，其中将过程的形式参数约束到调用时的实际参数，而后在新的环境的上下文中求值过程体。 对于一个给定环境求值一个lambda表达式，将创建起一个过程对象，它是一个序对，由该lambda表达式的正文和一个指向环境的指针组成，这个指针指向创建这个过程对象的环境。 2.2内部定义 以局部过程定义作为程序模块化的技术里的两个关键性质： 局部过程的名字不会与包容它们的过程之外的名字相互干扰。 局部过程只需将包含着它们的过程的形参作为自由变量，就可以访问该过程的实际参数。 3.用变动数据做模拟3.1变动的表 通过两个操作set-car!和set-cdr!去分别改变一个序对的car和cdr指针的指向来实现变动的表。 3.2队列 队列是一个先进先出的数据结构，这里主要是引入首尾指针的思想来加速对队列末端的访问。 3.3二维表格 二维表格里的每个值由两个关键码的索引，我们将这个表格构造为一个一维表格，其中的每个关键码又标识了一个子表格。 3.4数字电路的模拟器 这是被称为事件驱动的模拟程序的一个代表，在这类系统里一些事件引发另一些在随后时间发生的事件，它们又会引发随后的事件，并如此继续下去。 3.5约束的传播 通过构造约束网络组合各种约束，约束通过连接器连接起来。当某个连接器被给定了一个值时，它就会去唤醒所有与之关联的约束，通知它们自己有了新值，并如此继续下去。 4.并发：时间是一个本质的问题4.1并发系统中时间的性质 复杂性原因：多个进程有可能共享同一个状态变量。 并发程序正确性的两种限制方式： 一种严格的限制方式：修改任意共享状态变量的两个操作都不允许同时发生。 另一种不那么严格的方式：保证并发系统产生出的结果与各个进程按照某种方式顺序运行产生出的结果完全一样。 4.2控制并发的机制 串行化组：创建一些不同的过程集合，并且保证在每个时刻，在任何一个串行化集合里至多只有一个过程的一个执行。 从本质上看，在并发控制中，任何时间概念都必然与通信有内在的密切联系。有意思的是，时间与通信之间的这种联系也出现在相对论里，在那里的光速（可能用于同步事件的最快信号）是与时间和空间有关的基本常量。在处理时间和状态时，我们在计算模型领域所遭遇的复杂性，事实上，可能就是物理世界中最基本的复杂性的一种反映。 5.流 流是另一条对状态进行模拟的途径，它的核心是一种数学函数的思想： 我们将一个量$x$的随时间变化的行为，描述为一个时间的函数$x(t)$。如果我们关注的是每个时刻下的$x$，那么可以看作是一个变化着的量。如果我们关注值的整个时间史，那么就不需要强调其中的变化—函数$x(t)$没有改变。 5.1流的实现 基本想法：做出一种安排，只是部分地构造出流的结构，并送给使用流地程序，如果还需要访问尚未构造出的部分，则会自动继续构造下去。 特殊形式delay：求值(delay &lt;exp&gt;)返回一个延时对象，可以看作是对在未来的某个时间求值&lt;exp&gt;的许诺。 过程force：以一个延时对象为参数，执行相应的求值工作。 5.2流计算模式的使用 我们可以将整个的时间序列作为有关的目标，而不是去关注状态变量在各个时刻的值。这将使我们更方便地组合与比较来自不同时刻的状态的组合。 将迭代操作表示为流操作 123456; 求解一个数的平方(define (sqrt-stream x) (define guesses (cons-stream 1.0 (stream-map (lambda (guess) (sqrt-improve guess x)) guesses))) 序对的无穷流 这里主要是生产序对$(i,j)$，并且$i&lt;=j$ 1234567(define (pairs s t) (cons-stream (list (stream-car s) (stream-car t)) (interleave (stream-map (lambda (x) (list (stream-car s) x)) (stream-cdr t)) (pairs (stream-cdr s) (stream-cdr t))))) 将流作为信号 用流的元素表示为一个信号在顺序的一系列时间间隔上的值。 5.3函数式程序的模块化和对象的模块化 本章一开始就提出了其目标，那就是构造一些计算模型，使其结构能够符合我们对于试图去模拟的真实世界的看法，有下面的两种方式： 将这一世界模拟为一集相互分离的、受时间约束的、具有状态的相互交流的对象。 将它模拟为单一的、无时间也无状态的统一体。 我的解题代码 3.1 3.2 3.3 3.4 3.5 3.6 3.7 3.8 3.9 3.10 3.11 3.12 3.13 3.14 3.15 3.16 3.17 3.18 3.19 3.20 3.21 3.22 3.23 3.24 3.25 3.26 3.27 3.28 3.29 3.30 3.31 3.32 3.33 3.34 3.35 3.36 3.37 3.38 3.39 3.40 3.41 3.42 3.43 3.44 3.45 3.46 3.47 3.48 3.49 3.50 3.51 3.52 3.53 3.54 3.55 3.56 3.57 3.58 3.59 3.60 3.61 3.62 3.63 3.64 3.65 3.66 3.67 3.68 3.69 3.70 3.71 3.72 3.73 3.74 3.75 3.76 3.77 3.78 3.79 3.80 3.81 3.82 本文章由Perry创作，采用知识共享署名-非商业性使用-相同方式共享 3.0 中国大陆许可协议进行许可。凡是转载的文章，翻译的文章，或者由其他作者投稿的文章，版权归原作者所有。","comments":true,"tags":[{"name":"SICP","slug":"SICP","permalink":"http://yoursite.com/tags/SICP/"}]},{"title":"遇到的Hexo插件问题集合","date":"2019-03-18T21:20:41.000Z","path":"2019/03/19/hexo-plugin/","text":"从第一次接触Hexo到现在也写了几篇博客了，期间因为插件的问题头疼了好几次，耽误了不少时间，因此准备把自己遇到的几个问题写出来，来一次填坑。 遇到的问题分别是Tag标签搜索问题、Hexo部署问题、MathJax数学公式渲染问题。 1.Tags标签搜索问题在我们初次更换Yilia主题之后会发现所有文章功能里的Tag标签搜索功能无法使用，需要我们安装对应的插件，命令如下： 1npm i hexo-generator-json-content --save 并在根目录里的_config.yml文件里添加代码 123456789101112131415161718jsonContent: meta: false pages: false posts: title: true date: true path: true text: true raw: false content: false slug: false updated: false comments: true link: false permalink: false excerpt: false categories: false tags: true 2.Hexo部署问题当我们准备部署自己的博客，在运行hexo d -g命令时，可能会遇到报错ERROR Deployer not found:，说明我们缺失了deployer，需要进行安装 1npm install --save hexo-deployer-git 3.MathJax数学公式渲染问题在之前的一篇博客中我需要书写一些数学公式，在MarkDown编辑器中我写了如下的代码 123456789$$\\begin&#123;align&#125;0 &amp; \\rightarrow \\lambda f x.x \\\\1 &amp; \\rightarrow \\lambda f x.fx \\\\2 &amp; \\rightarrow \\lambda f x. f (f x) \\\\&amp; \\vdots \\\\N &amp; \\rightarrow \\lambda f x. f^nx \\\\\\end&#123;align&#125;$$ 并得到了如期的效果 可是生成静态页面后换行符完全不起作用，检查之后发现原来的hexo-renderer-marked插件并不能解析\\\\符号导致出错，需要我们升级到hexo-renderer-kramed。 我们需要运行下面的两条命令 12npm uninstall hexo-renderer-marked --save #卸载之前的hexo-renderer-markednpm install hexo-renderer-kramed --save #重新安装新的 本文章由Perry创作，采用知识共享署名-非商业性使用-相同方式共享 3.0 中国大陆许可协议进行许可。凡是转载的文章，翻译的文章，或者由其他作者投稿的文章，版权归原作者所有。","comments":true,"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"http://yoursite.com/tags/博客/"},{"name":"Plugin","slug":"Plugin","permalink":"http://yoursite.com/tags/Plugin/"}]},{"title":"SICP读书笔记--第2章《构造数据抽象》","date":"2019-03-18T21:00:07.000Z","path":"2019/03/19/sicp-second/","text":"一、说明 在第1章中我们关注了计算过程，讨论了程序设计语言的一个关键思想—-过程抽象。它的重要意义可能在于： 屏蔽计算的细节，将过程作为黑箱抽象，使用者只需要知道它的功能。 允许我们抽象出过程中的公共模式，允许我们对过程进行操作，形成高阶过程，达到更高一级的抽象。 本章将讨论的是程序设计语言的另一个方面：数据抽象。 本章小节分布 2.1数据抽象导引 2.2层次性数据和闭包性质 2.3符号数据 2.4抽象数据的多重表示 2.5带有通用型操作的系统 二、总结 与第1章对应，本章将讨论程序设计语言的另一个关键方面： 讨论如何将数据对象组合起来，形成复合数据的方式。这样做是为了提升我们在程序设计时所位于的概念层次，提高设计的模块性，增强语言的表达能力。 1.数据抽象导引 数据抽象的基本思想： 设法构造出一些使用复合数据对象的程序，使它们就像在“抽象数据”上操作一样。 我们使用构造函数和选择函数在具体的表示之上实现抽象的数据。 1.1序对我们使用cons将两个对象结合成一个对偶，形成一个复合数据对象，为了可以提取出cons里的两个对象，我们分别使用car和cdr去完成。后面我们会用序对构造更复杂的、被称为表的数据结构。 1.2抽象屏障复合数据的使用帮助我们提高了程序的模块性，因为它将程序中处理数据对象的表示的部分与处理数据对象的使用的部分相互隔离，数据抽象使我们在程序的不同部分之间建立起适当的抽象屏障。 值得注意的是，任一数据结构可以有多种方式将其表示为简单对象的组合，所以抽象屏障有下面的优点： 使程序很容易进行维护和修改，数据具体表示的改动对整体程序不会产生很大的影响。 只有少数界面对数据的具体表示存在依赖，允许我们推迟确定具体表示方法的时间，而不会阻碍系统其他部分的工作进展。 1.3数据意味什么？数据就是一些简单的数字、字符？或者它们组合起来的稍微复杂的一些东西吗？这样的想法可能有点简单！ 来看一个有点颠覆但又非常合理的定义： 我们总可以将数据定义为一组适当的选择函数和构造函数，以及使这些过程变成合法表示而需要的一组特定条件。 现在我们就可以使用过程来定义序对了： 123456789(define (cons x y) (define (dispatch m) (cond ((= m 0) x) ((= m 1) y) (else (error \"Argument not 0 or 1 -- CONS\" m)))) dispatch) ;返回的是一个接收单参数的判断选择过程(define (car z) (z 0)) ;向过程z传递参数0(define (cdr z) (z 1)) ;向过程z传递参数1 上面的程序还是出现了x和y这样的具体数据，干脆把数字这种基本的东西也用过程定义吧！ Church就用了λ表达式定义了的自然数，并且满足自然数的形式化定义（皮亚诺公理） \\begin{align} 0 & \\rightarrow \\lambda f x.x \\\\ 1 & \\rightarrow \\lambda f x.fx \\\\ 2 & \\rightarrow \\lambda f x. f (f x) \\\\ & \\vdots \\\\ N & \\rightarrow \\lambda f x. f^nx \\\\ \\end{align}其中，$f^n$表示$f$函数连续迭代$n$次，即$f^n x= f (f ( \\cdots (f x) \\cdots ))$ 。代码实现可参考练习2.6 2.层次性数据和闭包性质 某种组合数据对象的操作满足闭包性质 通过它组合起来的数据对象本身还可以通过同样的操作再进行组合。 闭包性质使我们可以建立起层次性的结构。 2.1序列表示和表操作 我们使用(list &lt;a1&gt; &lt;a2&gt; ... &lt;an&gt;)来定义表，它等价于一个序对的序列： (cons &lt;a1&gt; (cons &lt;a2&gt; (cons ... (cons &lt;an&gt; &#39;()) ... ))) 表操作： (list-ref items n)取表的第n个元素 (length items)取表的长度 (append list1 list2)把list2接在list1后面 表的映射 (map proc items)对表里的每个元素执行proc操作 2.2层次性结构 一个序列的元素本身也是序列，应用这种递归的表示，我们可以表示出树—-一种层次性结构的数据。 2.3序列作为一种约定的界面 对于一些序列的操作我们总可以抽象为下面的一种模块化的约定界面(顺序可调整)： 枚举每一个元素 过滤出满足条件的元素 对满足条件的元素进行操作 累积上面的结果 3.数据导向的程序设计 为了维护程序的模块性，将介绍数据导向的程序设计技术，它允许我们孤立地设计每一种数据表示，而后用添加的方式将它们组合。 下面我们辨析一下数据导向里的两种程序分派方式： 3.1基于类型的分派（也称数据导向） 是一种基于类型进行分派的组织方式，其中让每个操作管理自己的分派。 从效果上来看，这种方式是将操作-类型表格按行分解，每个通用型过程表示表格中的一行。采用一批“智能操作”去基于数据类型进行分派。 如果新增类型，只需再增加一个程序包即可，不需要修改源代码。 如果新增操作，同样也不需要修改之前的代码，只需要增加相应的分发函数即可。 数据导向可以很方便地通过包机制增加新类型和新的通用操作，因此无论是增加新类型还是增加新操作，这种策略都很适合。 3.2基于操作名的分派（消息传递） 这种方式是将操作-类型表格按列分解，采用一批“智能数据对象”去基于操作名进行分派。 如果这样做就需要做出一种安排，将每一个数据对象表示为一个过程。它以操作的名字作为输入，能够去执行指定的操作。 如果新增类型，只需再增加一个分发过程，原有代码不需要修改。 如果新增操作，则需要修改每个分发过程，把新增的操作添加上。 消息传递将数据对象和数据对象所需的操作整合在一起，因此它可以很方便地增加新类型，但是这种策略不适合增加新操作，因为每次为某个数据对象增加新操作之后，这个数据对象已有的实例全部都要重新实例化才能使用新操作。 三、本章习题解答 2.1 2.2 2.3 2.4 2.5 2.6 2.7 2.8 2.9 2.10 2.11 2.12 2.13 2.14 2.15 2.16 2.17 2.18 2.19 2.20 2.21 2.22 2.23 2.24 2.25 2.26 2.27 2.28 2.29 2.30 2.31 2.32 2.33 2.34 2.35 2.36 2.37 2.38 2.39 2.40 2.41 2.42 2.43 2.44 2.45 2.46 2.47 2.48 2.49 2.50 2.51 2.52 2.53 2.54 2.55 2.56 2.57 2.58 2.59 2.60 2.61 2.62 2.63 2.64 2.65 2.66 2.67 2.68 2.69 2.70 2.71 2.72 2.73 2.74 2.75 2.76 2.77 2.78 2.79 2.80 2.81 2.82 2.83 2.84 2.85 2.86 2.87 2.88 2.89 2.90 2.91 2.92 2.93 2.94 2.95 2.96 2.97 本文章由Perry创作，采用知识共享署名-非商业性使用-相同方式共享 3.0 中国大陆许可协议进行许可。凡是转载的文章，翻译的文章，或者由其他作者投稿的文章，版权归原作者所有。","comments":true,"tags":[{"name":"SICP","slug":"SICP","permalink":"http://yoursite.com/tags/SICP/"}]},{"title":"SICP读书笔记--第1章《构造过程抽象》","date":"2019-03-17T16:50:23.000Z","path":"2019/03/18/sicp-first/","text":"一、说明 读完了SICP的第四章，也完成了大部分的习题。是时候来写一点总结和分享一下自己的心得了，这篇博文主要的目的就是写一下对第1章《构造过程抽象》的总结，并且展示自己不成熟的解题代码，同各位爱好者进行交流，希望大家指出其中的不足！ 第1章共有3小节内容，分别是： 1.1程序设计的基本元素 1.2过程与它们所产生的计算 1.3用高阶函数做函数 二、总结1.程序设计的基本元素 最一开始，作者就为我们指出了每一种强有力的语言应该提供的三种机制： 基本表达形式：语言里最简单的个体。 组合的方法：允许我们从简单的东西出发构造出复杂的元素。 抽象的方法：允许我们为复合对象命名，并将它们当做单元去操作。 接下来就是本书的又一个重要的概念—-环境，它同时也是一种简单而又强有力的抽象方式 define就是上面所说的抽象方法：允许我们用一个名字去引用一个组合运算的结果。 有了这个方法我们就可以用一个简单的名字去代替复杂的对象和程序，方便我们以后用它们创造更复杂的东西。 为了完成上面的功能，解释器维护了一种存储能力，它保持了有关的名字-值对偶的轨迹。这种存储就被称为环境（更精确地说是全局环境）。 在我看来define就是一种受限的抽象手段，因为它强制了一种关联，其实就是lambda的一个语法糖衣而已。 接下来就是利用define去完成过程的定义： 1(define (&lt;name&gt; &lt;formal parameters&gt;) &lt;body&gt;) &lt;name&gt;是一个符号，后面将作为这个过程在环境里的名字，&lt;formal parameters&gt;是一个形参列表，&lt;body&gt;叫过程体，由一系列的表达式（组合式）组成。 对于组合式的求值，解释器将按照下面的过程工作 求值组合式的各个子表达式。 将作为最左子表达式（运算符）的值的那个过程应用于相应的实参，即子表达式的值。 对于求值子表达式，有下面的规定 数的值就是它们表示的值。 内部运算符的值就是对应的机器指令序列。 其他名字的值就是环境中这个名字关联的对象。 仔细想想上面的几个小点，将发现这一求值过程是递归的，如果还不清楚的话，请想想(* (+ 2 (* 4 6)) (+ 3 5 7))的求值过程。 过程应用的过程与上面的类似： 在将过程体中的每个形参用相应的实参取代之后，对这一过程体求值。 这种计算过程称为过程应用的代换模型，我们需要注意下面的几点 代换模型只给出了求值器求值过程的简单、一般的形式化描述。 代换模型只是为了帮助直观理解过程应用的行为。 代换模型不足以解释复杂的求值过程，这在引入的赋值和局部状态之后更加明显。 对于第4点中，求值子表达式和把过程应用于得到的实参这两个的先后问题引出了下面的应用序、正则序的概念 正则序：完全展开而后规约。 应用序：先求值参数而后应用。 大部分解释器会采用应用序，但是正则序在后面引入惰性求值之后将发挥出巨大的威力。 再回到之前的过程定义，我们将考虑下面的几个概念 形式参数与具体名字的名字无关，它只在过程定义的局部作用域里有效，被称为约束变量。 在过程定义的内部可以定义这个过程需要用到的一些子过程，同样满足于局部作用域的限制，这样的嵌套定义称为块结构。 2.过程与它们所产生的计算 一个过程就是一种模式，它描述了一个计算过程的局部演化方式。 递归 1234(define (fac n) (if (= n 1) 1 (* n (fac (- n 1))))) 我们来看一下上面定义的过程的计算过程 12345678910(fac 5)(* 5 (fac 4))(* 5 (* 4 (fac 3)))(* 5 (* 4 (* 3 (fac 2))))(* 5 (* 4 (* 3 (* 2 (fac 1)))))(* 5 (* 4 (* 3 (* 2 1))))(* 5 (* 4 (* 3 2)))(* 5 (* 4 6))(* 5 24)120 代换模型为我们揭示了一种先逐步展开而后收缩的形状，展开阶段构造起一个推迟进行的操作形成的链条，收缩阶段表现为运算的实际执行，这样的计算过程称为递归计算过程。这种过程的特点就是用链条去保存中间计算的一些信息，以便收缩时可以回到正确的原点。 迭代 12345678(define (fac n) (define (iter product counter max-count) (if (&gt; counter max-count) product (iter (* counter product) (+ counter 1) max-count))) (iter 1 1 n)) 我们来看一下上面定义的过程的计算过程 12345678(fac 5)(iter 1 1 5)(iter 1 2 5)(iter 2 3 5)(iter 6 4 5)(iter 24 5 5)(iter 120 6 5)120 我们看到这样的过程是用变量product、counter、max-count去保存轨迹，称这样的计算为迭代计算过程。它有下面的特点： 其状态可以用固定数目的状态变量描述。 存在一套固定的规则，描述了计算过程从一个状态到下一状态时变量的更新方式。 存在一个结束检测，描述了计算过程的终止条件。 在迭代计算的任何时间点，状态变量都提供了计算状态的一个完整描述，意味着我们可以轻易地在计算停止之后通过向解释器提供状态变量的值来唤醒它。 3.用高阶函数做抽象 程序语言的必然要求：能为公共的模式命名，建立抽象，而后直接在抽象的层次上工作。 在Scheme中允许我们以过程作为参数，或者以过程作为返回值描述上面的模式，这类能操作过程的过程被称为高阶过程。 过程作为参数 如上面所说的我们可以把一个公共模式提取出来，只考虑它的一般情况，而不是考虑一些具体的表达，建立一般的抽象。在这里我们的参数可能不再只是简单的变量，而可能是一些一般化的过程。 回忆一下求和公式： \\sum_{n=a}^bf(n)=f(a)+ \\cdots +f(b)看看这个公式的代码吧 12345(define (sum f a next b) (if (&gt; a b) 0 (+ (f a) (sum f (next a) next b)))) 这里的f就是公式里的$f$，只是一个一般化的形式描述，没有具体的定义，next描述的是变量怎么从一个状态到另一个状态，也没有具体的定义。 可以看到将过程作为参数成功地帮助我们从一些具体的描述里解脱出来，开始可以用一个抽象描述一个更一般化的抽象。 用lambda构造过程 有时候我们没有必要将过程和一个名字绑定起来，那我们就可以使用lambda去定义这个过程，它不需要我们为过程提供名字 1(lambda (&lt;formal-parameters&gt;) &lt;body&gt;) 用let创建局部变量 一般形式： 123456(let ((&lt;var1&gt; &lt;exp1&gt;) (&lt;var2&gt; &lt;exp2&gt;) : : (&lt;varn&gt; &lt;expn&gt;)) &lt;body&gt;) 它表示令$$分别具有值$$，然后带入中求值。L2Dwidget.init({\"pluginRootPath\":\"live2dw/\",\"pluginJsPath\":\"lib/\",\"pluginModelPath\":\"assets/\",\"tagMode\":false,\"debug\":false,\"model\":{\"jsonPath\":\"/live2dw/assets/hijiki.model.json\"},\"display\":{\"position\":\"right\",\"width\":150,\"height\":300},\"mobile\":{\"show\":true},\"log\":false}); 过程作为返回值 有时因为形参和过程的特殊性，最后得到的可能不是具体的值，而是一个中间的过程。 比如 12(define (average-damp f) (lambda (x) (average x (f x)))) average-damp的形参是一个过程f，返回的是求x和(f x)平均值的过程。 抽象和第一级过程 高阶过程的重要性，在于使我们能显式地用程序设计语言的要素去描述这些抽象，使我们能像操作其他计算元素一样操作它们。 带有最少限制的元素称为具有第一级的状态，第一级元素具有的“特权”有： 可以用变量命名 可以提供给过程作为参数 可以由过程作为结果返回 可以包含在数据结构中 最后一点我们会在第2章时领略到，对于Scheme来说，它给了过程完全的第一级状态。 三.我的解题代码 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 1.10 1.11 1.12 1.13 1.14 1.15 1.16 1.17 1.18 1.19 1.20 1.21 1.22 1.23 1.24 1.25 1.26 1.27 1.28 1.29 1.30 1.31 1.32 1.33 1.34 1.35 1.36 1.37 1.38 1.39 1.40 1.41 1.42 1.43 1.44 1.45 1.46 本文章由Perry创作，采用知识共享署名-非商业性使用-相同方式共享 3.0 中国大陆许可协议进行许可。凡是转载的文章，翻译的文章，或者由其他作者投稿的文章，版权归原作者所有。","comments":true,"tags":[{"name":"SICP","slug":"SICP","permalink":"http://yoursite.com/tags/SICP/"}]},{"title":"环形链表问题的证明","date":"2019-03-14T16:15:02.000Z","path":"2019/03/15/list-cycle/","text":"一、说明在LeetCode上有这样两道关于环形链表的题目： No.141 描述：给定一个链表，判断链表中是否有环。题目链接 No.142 描述：给定一个链表，返回链表开始入环的第一个节点。题目链接 这篇文章主要做一下解题方法—-快慢指针法的正确性证明。 二、证明1.证明快慢指针在环中是可以恰好相遇的 设链表的头结点为$x_0$，环的起始结点为$x_s$，环的结点个数为$l$。当我们从$x_0$开始遍历链表的话可以得到下面的一个无穷序列： x_0, x_1,\\cdots,x_s,x_{s+1},\\cdots,x_{s+l-1},x_s,\\cdots假设$j$是$l$的整数倍且是满足$j&gt;s$的最小的那一个，对于任意的正整数$k(k\\geq2)$，考虑两个结点位置$xj$和$x{kj} $（即慢指针走到了$xj$，快指针走到了$x{kj}$），容易知道的事实是：$xj$肯定在环中。那么$x{kj}$也在环中，因为$kj=j+(k-1)j$，可以认为$x{kj}$是从$x_j$开始多走了$k-1$个$j$步，所以$x_j=x{kj}​$。 综上，两个指针一定会恰好相遇！ 那么为了以最快的速度让两个指针相遇，我们应该让$k$尽可能小，所以$k$取2。所以让慢指针走1步，而快指针走2步！ 2.解题代码 其他题目的代码(C++, Java, Python)，包括一些经典数据结构和算法的实现也放在了我的GitHub上。 2.1.第一题代码12345678910111213141516171819202122/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool hasCycle(ListNode *head) &#123; ListNode* slow = head; //慢指针 ListNode* fast = head; //快指针 while(slow != NULL &amp;&amp; fast != NULL &amp;&amp; fast-&gt;next != NULL)&#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; //快指针走两步 if(slow == fast) return true; &#125; return false; &#125;&#125;; 2.2.第二题代码12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; ListNode* slow = head; ListNode* fast = head; while(fast != NULL &amp;&amp; fast-&gt;next !=NULL)&#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; if(slow == fast)&#123; fast = head; while(fast != slow)&#123; fast = fast-&gt;next; slow = slow-&gt;next; &#125; return slow; &#125; &#125; return NULL; &#125;&#125;; 本文章由Perry创作，采用知识共享署名-非商业性使用-相同方式共享 3.0 中国大陆许可协议进行许可。凡是转载的文章，翻译的文章，或者由其他作者投稿的文章，版权归原作者所有。","comments":true,"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"我的书单（一）","date":"2019-03-12T04:55:19.000Z","path":"2019/03/12/booklist1/","text":"读书带给人的是精神上的富足，会让你在精神得到满足之余，有一种孤独感。 大学期间，从大三开始陆陆续续也读了一点书籍，好多也是因为别人的推荐才知道的，也很感激那些推荐者，所以今天也来推荐一下我读过的一些好书！这些书有的是读完的，有的正在读，但都是我觉得还不错的书。 一、数学类 数学是自然科学的基础，计算机更是由数学家创造出来的，培养好的数学素养对以后的学习是非常有必要的！ 1.代数 — Artin 这本书是由当代领袖型代数学家与代数儿何学家之一的Atrin写作的，是一本代数学的经典著作，既介绍了矩阵运算、群、向量空间、线性变换、对称等较为基本的内容，又介绍了环、模、域、伽罗瓦理论等较为高深的内容，对于提高数学理解能力、增强对代数的兴趣是非常有益处的。 2.组合数学 — 冯荣权、宋春伟 这本书出自北大数学系教授之手，注重对抽象概念和定理的理解，强调方法的运用以及组合数学在各个领域的应用。因为理论性比较高，所以初步读起来会觉得比较困难，但理解了之后会觉得非常有趣。 二、计算机类1.计算机程序的构造和解释 这本书是MIT盛行多年的一本教材，它不仅仅是在教授计算机技术，我觉得里面更多的计算机科学方面的知识，作者使用了简单的函数式语言Scheme带领读者初步探索了精彩绝伦的计算机科学理论的世界！个人觉得是目前读过最精彩的书！ 前4章的习题解答我也放在了GitHub上。 2.算法导论 不多说，这本书是学习算法的人都有读过的，里面的内容也是非常的丰富，想读懂里面的内容是需要一定的基础的，想读完它更是需要花费大量的时间的。 我的一些算法练习和本书里一些经典算法的实现代码放在了这里。 3.编程珠玑 在书中，作者选取许多具有典型意义的复杂编程和算法问题，生动描绘了历史上众大师们在探索解决方案中发生的轶事、走过的弯路和不断精益求精的历程，引导读者像真正的程序员和软件工程师那样富于创新性地思考，并透彻阐述和总结了许多独特而精妙的设计原则、思考和解决问题的方法以及实用程序设计技巧。解决方案的代码均以C/C++语言编写，不仅有趣，而且有很大的实战示范意义。每章后所附习题极具挑战性和启发性，书末给出了简洁的解答。 4.C++ Primer 这本是久负盛名的 C++经典教程，深入浅出地为我们讲解了C++11标准里的各种知识和原理，教会我们怎么进行高效的现代C++编程 5.Effective C++ 这是C++领域的经典大作，与《C++ Primer》的广博不同，这本书只是列出了55个编程准则，但都是非常实用的经验准则，是一本短小精悍的“专家经验积累” 6.统计学习方法 书中罗列了10个统计学习方法，并且书的厚度相比同类的其他书籍真的很少，适合入门学习。 7.机器学习 周志华的经典之作，不做其他介绍。 本文章由Perry创作，采用知识共享署名-非商业性使用-相同方式共享 3.0 中国大陆许可协议进行许可。凡是转载的文章，翻译的文章，或者由其他作者投稿的文章，版权归原作者所有。","comments":true,"tags":[{"name":"书单","slug":"书单","permalink":"http://yoursite.com/tags/书单/"},{"name":"BookList","slug":"BookList","permalink":"http://yoursite.com/tags/BookList/"}]},{"title":"SICP的小练习--Scheme语言实现3个经典的排序算法","date":"2019-02-25T08:09:54.000Z","path":"2019/02/25/scheme-sort/","text":"一、说明 从去年11月份开始了《计算机程序的构造和解释》这本书的学习，开始接触了函数式。学习过程中也对编程有了新的理解，对递归这一程序设计技术也有了更深的掌握。其间为了自娱自乐用Scheme这一小众的函数式语言实现了3个经典排序算法，分别是快速排序、归并排序、堆排序。 目前我已经学习并完成了那本书的前三章的内容和习题，所有的代码也放在了GitHub仓库里，如果有对那本书感兴趣的朋友，可以一起讨论学习。 二、具体算法实现1.快速排序1.1.算法核心思想 每次选取第一个元素作为基准，并采用过滤器filter将剩余元素中小于等于基准的作为small部分、剩余元素中大于基准的作为big部分，然后对small和big部分进行快速排序，最后按small-基准-big的顺序组合成新的列表，直到列表中只有一个元素为止. 1.2.完整代码实现12345678(define (quicksort L) (if (null? L) '() (let ((small (quicksort (filter (lambda (x) (&lt;= x (car L))) (cdr L)))) (big (quicksort (filter (lambda (x) (&gt; x (car L))) (cdr L))))) (append small (cons (car L) big))))) 代码文件 2.归并排序2.1.算法核心思想 合并两个列表L1、L2 如果L1、L2中有一个为空，则返回另一个. 否则分别取L1、L2的首元素x1、x2 如果x1小于等于x2，则将x1作为新列表的首元素，并继续合并L1的剩余部分和L2. 如果x1大于x2，则将x2作为新列表的首元素，并继续合并L1和L2的剩余部分. 12345678(define (merge L1 L2) (cond ((null? L1) L2) ((null? L2) L1) (else (let ((x1 (car L1)) (x2 (car L2))) (if (&lt;= x1 x2) (cons x1 (merge (cdr L1) L2)) (cons x2 (merge L1 (cdr L2)))))))) 归并排序 每次选取列表的头两个元素进行合并然后舍弃，并将合并之后元素放置列表末尾，继续对新列表进行归并排序，直到列表中只有一个元素. 123456789101112(define (merge-sort L) (define (transform x) (if (number? x) (list x) x)) (cond ((null? L) '()) ((= (length L) 1) (car L)) (else (let ((l1 (transform (car L))) (l2 (transform (cadr L)))) (let ((new (list (merge l1 l2)))) (merge-sort (append (cddr L) new))))))) 2.2.完整代码实现 代码文件 3.推排序3.1.算法核心思想 首先将数组映射为一棵完全二叉树 规则：对于 i 下标位置的元素，它的左孩子下标为 2*i+1，右孩子下标为 2*(i+1)​. 维护一个以root下标为根，末尾下标为len的大根堆 如果root的两个孩子有比它大的，则将root和那个最大元素交换位置，并对那个子树进行递归维护. 123456789101112131415161718192021(define (MaxHeapify heap root len) (define (Left i) (+ (* i 2) 1)) (define (Right i) (* (+ i 1) 2)) (let ((left (Left root)) (right (Right root)) (largest root)) (begin (if (and (&lt;= left len) (&gt; (vector-ref heap left) (vector-ref heap root))) (set! largest left)) (if (and (&lt;= right len) (&gt; (vector-ref heap right) (vector-ref heap largest))) (set! largest right)) (if (not (= largest root)) (let ((head (vector-ref heap root))) (begin (vector-set! heap root (vector-ref heap largest)) (vector-set! heap largest head) (MaxHeapify heap largest len))))))) 初始化大根堆 从堆中的最后一个有孩子的节点开始从右向左、从下向上，以每个节点为根维护一个大根堆. 1234567(define (BuildMaxHeap heap) (define (build-iter i) (if (&gt;= i 0) (begin (MaxHeapify heap i (- (vector-length heap) 1)) (build-iter (- i 1))))) (build-iter (- (div (vector-length heap) 2) 1))) 堆排序 从初始的大根堆开始，每次将0下标位置和len下标位置的元素交换，并len := len-1，然后继续对0到len位置的元素进行堆排序，直到len = 0. 123456789101112(define (HeapSort heap) (define (sort-iter i) (if (&gt;= i 1) (let ((max (vector-ref heap 0))) (begin (vector-set! heap 0 (vector-ref heap i)) (vector-set! heap i max) (MaxHeapify heap 0 (- i 1)) (sort-iter (- i 1)))))) (BuildMaxHeap heap) (sort-iter (- (vector-length heap) 1)) heap) 3.2.完整代码实现 代码文件 本文章由Perry创作，采用知识共享署名-非商业性使用-相同方式共享 3.0 中国大陆许可协议进行许可。凡是转载的文章，翻译的文章，或者由其他作者投稿的文章，版权归原作者所有。","comments":true,"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"Scheme","slug":"Scheme","permalink":"http://yoursite.com/tags/Scheme/"},{"name":"函数式","slug":"函数式","permalink":"http://yoursite.com/tags/函数式/"},{"name":"SICP","slug":"SICP","permalink":"http://yoursite.com/tags/SICP/"}]},{"title":"利用Github和Hexo搭建Yilia主题的博客","date":"2019-02-21T13:21:14.000Z","path":"2019/02/21/hexo-yilia/","text":"一、说明 前面几天时间利用Github和Hexo搭建Yilia主题的博客，过程中也踩了很多的坑，现在也到了填坑的时候了。 废话不多说，现在正式开始教程吧。 1.基本软件安装 首先我们需要从Node.js官网下载并安装这个软件。 安装成功之后我们在cmd窗口中输入命令：node --version，如果可以得到相对应的版本号则说明安装成功，否则请将安装目录添加到PATH环境变量中。 另外我们还需要安装Git，并且还需要配置与Github的SSH Key，需要的话可以参考我的上一篇文章。 2.创建Github仓库 登录GitHub后我们新建一个名为userName.github.io的仓库，userName就是你账户的名字。 建好之后打开这个仓库的Settings页面，在GitHub Pages我们可以看到类似于这样的显示： 这里绿色区域显示的网址就是我们博客的网址，因为这个网址有点长，资金允许的话我们可以将它绑定到自己申请的域名，这将在后面进行介绍。 二、Hexo的安装和一些基本命令、配置1.安装Hexo 打开cmd窗口，运行命令：npm install -g hexo进行安装。 初始化Hexo：新建一个名为blog的文件夹，在PowerShell窗口中运行命令hexo init。 重新打开文件夹之后我们发现多出了这样一些文件 source文件夹：这里存放的是博客所有的资源文件，书写文章的Markdown文件存放在_posts子文件夹中，文章的图片资料可以新建imgs文件夹并存放。 themes文件夹：这里存放的是博客的主题文件，其中的landspace是默认的主题文件，之后我们更换的Yilia主题文件也将存放在这里。 _config.yml文件：这是博客的一些基本配置记录，我们后面将对它进行更改。 2.基本配置打开_config.yml文件进行配置 基本信息展示： 部署方式配置 关于头像和站点图标的更换将在更换主题之后进行。 3.基本命令 生成静态页面：hexo g。 启动本地服务器：hexo s。 默认的端口号是4000，如果冲突的话可以通过命令hexo s -p5000更换指定的端口号。 之后我们就可以在浏览器中访问http://localhost:4000查看自己的博客情况。 新建文章：运行命令hexo new &quot;xxxx&quot;，在source\\_posts文件夹生成新的Markdown文件，后面就可以在这个文件上完成自己的文章。 部署到GitHub：在搭建完博客或者写完文章之后我们需要把它们部署到GitHub上供人浏览。我们依次运行下面的两条命令完成： hexo clean hexo d -g 如果报错提示：ERROR Deployer not found:，那么我们需要安装deployer插件，运行下面的命令 1npm install --save hexo-deployer-git 三、更换Yilia主题及它的基本配置 1.更换主题之前说过的，我们可以将下载好的主题文件放在themes文件夹里进行主题更换。这里提供了很多别人开发好的主题，我使用的是Yilia主题。下面具体说说怎么更换： 在themes文件夹下打开Git Bash，运行git clone git@github.com:litten/hexo-theme-yilia.git。 打开blog文件夹下的_config.yml文件，将其中的theme属性的值改为刚刚下好的文件名即可。 1theme: hexo-theme-yilia 2.基本配置2.1.更换头像和站点图标 打开文件夹themes\\hexo-theme-yilia\\source\\img，将头像、站点图标以及两个打赏二维码图片放在这里。 打开主题文件夹下的_config.yml文件，并对avatar和favicon做如下更改： 12favicon: /img/favicon.jpgavatar: /img/avatar.jpg 2.2.配置打赏图片 还是对_config.yml文件进行修改： 1234# 支付宝二维码图片地址，跟你设置头像的方式一样alipay: /img/alipay.jpg# 微信二维码图片地址weixin: /img/weixin.jpg 2.3.标签功能缺失模块的补充 在blog文件夹下执行命令：npm i hexo-generator-json-content --save 在blog文件夹中的_config.yml文件末尾添加代码： 123456789101112131415161718jsonContent: meta: false pages: false posts: title: true date: true path: true text: true raw: false content: false slug: false updated: false comments: true link: false permalink: false excerpt: false categories: false tags: true 2.4.百度统计设置百度统计官网 注册完之后点击新增网站，前面的两个值填写的是GitHub为我们生成的网址即可 在代码获取页面复制官方生成的代码 将复制的代码添加到目录hexo-theme-yilia\\layout\\_partial中的baidu_tongji.ejs中，格式为： 12&lt;% if (theme.baidu_tongji) &#123; %&gt;# 你刚复制的所有代码 打开主题目录下的_config.yml文件，将其中的baidu_analytics的值修改为统计代码中hm.src值的’?‘之后一段字符。 123# Miscellaneousbaidu_analytics: '0f94e44d75ef0e72600xxxxxxxxxxxxx'google_analytics: '' 2.5.其他一些链接更改 这里主要是我对主题里一些链接的更改： 1234567891011121314151617# SubNavsubnav: github: \"https://github.com/Perry961002\" weibo: \"#\" rss: \"#\" mail: \"mailto:Perry961002@163.com\" #友情链接friends: Github官网: https://github.com/ Markdown编辑器Typora: https://www.typora.io/ 阿里云: https://www.aliyun.com/ VSCode官网: https://code.visualstudio.com/ LeetCode中国: https://leetcode-cn.com/#自我展示aboutme: 爱好数学和算法的码农&lt;br&gt;&lt;br&gt;喜欢乒乓球的吃货。。。 四、博客进阶功能设置1.网站访问量和文章阅读量统计 这里我使用的是不蒜子提供的插件 打开目录hexo-theme-yilia\\layout\\_partial下的footer.ejs文件，在末尾添加代码 12&lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 还是在footer.ejs文件中，在footer-left和footer-right标签之间添加代码 123456&lt;span id=&quot;busuanzi_container_site_pv&quot;&gt; 本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt;&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 本站访客数&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人次&lt;/span&gt; 打开同目录下的article.ejs文件，在&lt;%- partial(&#39;post/title&#39;, {class_name: &#39;article-title&#39;}) %&gt;一行下添加代码 123456789&lt;!-- 显示阅读和评论数 --&gt;&lt;% if (!index)&#123; %&gt; &lt;br/&gt; &lt;a class=&quot;cloud-tie-join-count&quot; href=&quot;javascript:void(0);&quot; style=&quot;color:gray;font-size:14px;&quot;&gt; &lt;span class=&quot;icon-sort&quot;&gt;&lt;/span&gt; &lt;span id=&quot;busuanzi_container_page_pv&quot; style=&quot;color:#ef7522;font-size:14px;&quot;&gt; 本文阅读量: &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt;次 &amp;nbsp;&amp;nbsp; &lt;/span&gt; &lt;/a&gt; 效果： 网站访问量： 文章阅读量： 2.评论功能配置 在主题目录下的_config.yml文件中我们发现作者提供了多种方式来实现评论功能，但因为一些原因很多方式已经不能使用，这里我采用了Gitment评论功能。 Gitment是使用的GitHub Issues作为评论系统。 2.1.在GitHub上创建OAuth Apps 登录自己的Github，进入Settings--Developer settings页面，点击New OAuth App 这里name可以随便写，Homepage URL填GitHub提供的网址 如果博客绑定的域名，callback URL就需要使用绑定域名，否则和上面一样，最后确定即可。 完成之后可以得到 2.2.配置_config.yml文件 打开主题目录下的_config.yml文件，做下面的修改 1234567#5、Gitmentenable: truegitment_owner: Perry961002 #你的 GitHub IDgitment_repo: 'perry961002.github.io' #存储评论的 repogitment_oauth: client_id: 'e686axxxxxxxxx' #client ID client_secret: 'aea668xxxxxxxxxx' #client secret 2.3.配置Gitment的中文显示、解决Validation Failed错误 打开目录hexo-theme-yilia\\layout\\_partial\\post下的gitment.ejs文件，将2、3两行修改为 12&lt;link rel=&quot;stylesheet&quot; href=&quot;https://billts.site/extra_css/gitment.css&quot;&gt;&lt;script src=&quot;https://billts.site/js/gitment.js&quot;&gt;&lt;/script&gt; 将id属性的值修改为 1id: &quot;&lt;%= page.date %&gt;&quot; 最终效果： 3.文章目录功能 打开目录hexo-theme-yilia\\source下的main.0cf68a.css文件(这里文件名中间的那一段编号可能不一样)，添加下面的代码： 123456789/* 新添加的 */#container .show-toc-btn,#container .toc-article&#123;display:block&#125;.toc-article&#123;z-index:100;background:#fff;border:1px solid #ccc;max-width:250px;min-width:150px;max-height:500px;overflow-y:auto;-webkit-box-shadow:5px 5px 2px #ccc;box-shadow:5px 5px 2px #ccc;font-size:12px;padding:10px;position:fixed;right:35px;top:129px&#125;.toc-article .toc-close&#123;font-weight:700;font-size:20px;cursor:pointer;float:right;color:#ccc&#125;.toc-article .toc-close:hover&#123;color:#000&#125;.toc-article .toc&#123;font-size:12px;padding:0;line-height:20px&#125;.toc-article .toc .toc-number&#123;color:#333&#125;.toc-article .toc .toc-text:hover&#123;text-decoration:underline;color:#2a6496&#125;.toc-article li&#123;list-style-type:none&#125;.toc-article .toc-level-1&#123;margin:4px 0&#125;.toc-article .toc-child&#123;&#125;@-moz-keyframes cd-bounce-1&#123;0%&#123;opacity:0;-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)&#125;60%&#123;opacity:1;-o-transform:scale(1.01);-webkit-transform:scale(1.01);-moz-transform:scale(1.01);-ms-transform:scale(1.01);transform:scale(1.01)&#125;100%&#123;-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)&#125;&#125;@-webkit-keyframes cd-bounce-1&#123;0%&#123;opacity:0;-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)&#125;60%&#123;opacity:1;-o-transform:scale(1.01);-webkit-transform:scale(1.01);-moz-transform:scale(1.01);-ms-transform:scale(1.01);transform:scale(1.01)&#125;100%&#123;-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)&#125;&#125;@-o-keyframes cd-bounce-1&#123;0%&#123;opacity:0;-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)&#125;60%&#123;opacity:1;-o-transform:scale(1.01);-webkit-transform:scale(1.01);-moz-transform:scale(1.01);-ms-transform:scale(1.01);transform:scale(1.01)&#125;100%&#123;-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)&#125;&#125;@keyframes cd-bounce-1&#123;0%&#123;opacity:0;-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)&#125;60%&#123;opacity:1;-o-transform:scale(1.01);-webkit-transform:scale(1.01);-moz-transform:scale(1.01);-ms-transform:scale(1.01);transform:scale(1.01)&#125;100%&#123;-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)&#125;&#125;.show-toc-btn&#123;display:none;z-index:10;width:30px;min-height:14px;overflow:hidden;padding:4px 6px 8px 5px;border:1px solid #ddd;border-right:none;position:fixed;right:40px;text-align:center;background-color:#f9f9f9&#125;.show-toc-btn .btn-bg&#123;margin-top:2px;display:block;width:16px;height:14px;background:url(http://7xtawy.com1.z0.glb.clouddn.com/show.png) no-repeat;-webkit-background-size:100%;-moz-background-size:100%;background-size:100%&#125;.show-toc-btn .btn-text&#123;color:#999;font-size:12px&#125;.show-toc-btn:hover&#123;cursor:pointer&#125;.show-toc-btn:hover .btn-bg&#123;background-position:0 -16px&#125;.show-toc-btn:hover .btn-text&#123;font-size:12px;color:#ea8010&#125;.toc-article li ol, .toc-article li ul &#123; margin-left: 30px;&#125;.toc-article ol, .toc-article ul &#123; margin: 10px 0;&#125; 打开目录hexo-theme-yilia\\layout\\_partial下的article.ejs文件，在&lt;/header&gt; &lt;% } %&gt;下添加代码： 123456789101112131415161718192021222324252627&lt;!-- 目录内容 --&gt;&lt;% if (!index &amp;&amp; post.toc)&#123; %&gt; &lt;p class=&quot;show-toc-btn&quot; id=&quot;show-toc-btn&quot; onclick=&quot;showToc();&quot; style=&quot;display:none&quot;&gt; &lt;span class=&quot;btn-bg&quot;&gt;&lt;/span&gt; &lt;span class=&quot;btn-text&quot;&gt;文章导航&lt;/span&gt; &lt;/p&gt; &lt;div id=&quot;toc-article&quot; class=&quot;toc-article&quot;&gt; &lt;span id=&quot;toc-close&quot; class=&quot;toc-close&quot; title=&quot;隐藏导航&quot; onclick=&quot;showBtn();&quot;&gt;×&lt;/span&gt; &lt;strong class=&quot;toc-title&quot;&gt;文章目录&lt;/strong&gt; &lt;%- toc(post.content) %&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; function showToc()&#123; var toc_article = document.getElementById(&quot;toc-article&quot;); var show_toc_btn = document.getElementById(&quot;show-toc-btn&quot;); toc_article.setAttribute(&quot;style&quot;,&quot;display:block&quot;); show_toc_btn.setAttribute(&quot;style&quot;,&quot;display:none&quot;); &#125;; function showBtn()&#123; var toc_article = document.getElementById(&quot;toc-article&quot;); var show_toc_btn = document.getElementById(&quot;show-toc-btn&quot;); toc_article.setAttribute(&quot;style&quot;,&quot;display:none&quot;); show_toc_btn.setAttribute(&quot;style&quot;,&quot;display:block&quot;); &#125;; &lt;/script&gt; &lt;% &#125; %&gt; &lt;!-- 目录内容结束 --&gt; 需要注意的是：如果想在页面中显示目录，要在文章的Markdown的开头加入toc: true这样一句话。 效果： 五、绑定域名1.购买域名 首先需要在阿里云的域名模块购买属于自己的域名，我这里使用的是.com结尾的域名，加入云解析服务，第一年支付了73.36人民币。 2.域名解析 点开解析设置页面，添加两个记录，记录类型选CNAME，主机记录分别写@和www，记录值填GitHub生成的网址 在博客目录下的source文件夹下新建名为CNAME的文件，将域名信息写入并保存，比如我的就是填perry96.com。稍等几分钟之后就可以通过访问域名来访问自己的博客。 本文章由Perry创作，采用知识共享署名-非商业性使用-相同方式共享 3.0 中国大陆许可协议进行许可。凡是转载的文章，翻译的文章，或者由其他作者投稿的文章，版权归原作者所有。","comments":true,"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"http://yoursite.com/tags/博客/"},{"name":"Github","slug":"Github","permalink":"http://yoursite.com/tags/Github/"},{"name":"Yilia","slug":"Yilia","permalink":"http://yoursite.com/tags/Yilia/"}]},{"title":"Git和Github初次使用及配置","date":"2019-02-21T03:26:58.000Z","path":"2019/02/21/git-github/","text":"一、简单介绍 Git是一个开源的分布式版本控制系统，它可以很高效地进行项目版本管理。 Github是一个只支持Git作为唯一版本管理工具的面向开源和私有软件项目的托管平台。 二、Git安装及本地账户配置1.Git安装 我们需要从Git官网下载适合版本的安装包进行安装，因为过程中没有需要注意的地方，这里不再赘诉。 2.Git的账户配置 我们右击鼠标，打开Git Bash，输入下面两条命令进行用户名和邮箱设置： 12git config --global user.name \"username\" //引号内为GitHub用户名git config --global user.email useremail@example.com //这里用GitHub的注册邮箱 三、配置SSH访问Github 这里需要你提前注册一个Github账号，方法不再赘述。 1.Git创建本地SSH Key 右键鼠标，打开Git Bash，输入下面的命令创建本地SSH Key 1ssh-keygen -t rsa -C \"useremail@example.com\" //此处“C”要大写，邮箱使用GitHub注册邮箱 输入后中间会提示选择生产路径以及设置密码，为了后面使用方便我们一路回车跳过即可 创建成功之后会看见The key&#39;s randomart image is:这样一句话，下面会显示出一堆看不懂的图案。 之后我们打开.ssh文件夹中的id_rsa.pub文件，复制其中的所有内容，这里一定要全部复制，包括换行。 2.添加到Github 登录Github，点击Settings—-SSH and GPG keys—-New SSH key Title里的内容随便填，Key中粘贴之前复制的本地SSH key。 3.测试是否成功 打开Git Bash，输入下面的命令 1ssh -T git@github.com 如果配置成功将会出现下面的文字 1You&apos;ve successfully authenticated, but GitHub does not provide shell access. 本文章由Perry创作，采用知识共享署名-非商业性使用-相同方式共享 3.0 中国大陆许可协议进行许可。凡是转载的文章，翻译的文章，或者由其他作者投稿的文章，版权归原作者所有。","comments":true,"tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"},{"name":"Github","slug":"Github","permalink":"http://yoursite.com/tags/Github/"}]}]